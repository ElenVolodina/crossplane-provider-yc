/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessObservation struct {
}

type AccessParameters struct {

	// +kubebuilder:validation:Optional
	DataLens *bool `json:"dataLens,omitempty" tf:"data_lens,omitempty"`

	// +kubebuilder:validation:Optional
	Metrika *bool `json:"metrika,omitempty" tf:"metrika,omitempty"`

	// +kubebuilder:validation:Optional
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	// +kubebuilder:validation:Optional
	WebSQL *bool `json:"webSql,omitempty" tf:"web_sql,omitempty"`
}

type BackupWindowStartObservation struct {
}

type BackupWindowStartParameters struct {

	// +kubebuilder:validation:Optional
	Hours *int64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// +kubebuilder:validation:Optional
	Minutes *int64 `json:"minutes,omitempty" tf:"minutes,omitempty"`
}

type ClickhouseClusterObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ClickhouseClusterParameters struct {

	// +kubebuilder:validation:Optional
	Access []AccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef *v1.SecretKeySelector `json:"adminPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BackupWindowStart []BackupWindowStartParameters `json:"backupWindowStart,omitempty" tf:"backup_window_start,omitempty"`

	// +kubebuilder:validation:Required
	Clickhouse []ClickhouseParameters `json:"clickhouse" tf:"clickhouse,omitempty"`

	// +kubebuilder:validation:Optional
	CloudStorage []CloudStorageParameters `json:"cloudStorage,omitempty" tf:"cloud_storage,omitempty"`

	// +kubebuilder:validation:Optional
	CopySchemaOnNewHosts *bool `json:"copySchemaOnNewHosts,omitempty" tf:"copy_schema_on_new_hosts,omitempty"`

	// +kubebuilder:validation:Optional
	Database []DatabaseParameters `json:"database,omitempty" tf:"database,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Environment *string `json:"environment" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	FormatSchema []FormatSchemaParameters `json:"formatSchema,omitempty" tf:"format_schema,omitempty"`

	// +kubebuilder:validation:Required
	Host []HostParameters `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MaintenanceWindow []MaintenanceWindowParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// +kubebuilder:validation:Optional
	MlModel []MlModelParameters `json:"mlModel,omitempty" tf:"ml_model,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Optional
	SQLDatabaseManagement *bool `json:"sqlDatabaseManagement,omitempty" tf:"sql_database_management,omitempty"`

	// +kubebuilder:validation:Optional
	SQLUserManagement *bool `json:"sqlUserManagement,omitempty" tf:"sql_user_management,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

	// +kubebuilder:validation:Optional
	ShardGroup []ShardGroupParameters `json:"shardGroup,omitempty" tf:"shard_group,omitempty"`

	// +kubebuilder:validation:Optional
	User []UserParameters `json:"user,omitempty" tf:"user,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// +kubebuilder:validation:Optional
	Zookeeper []ZookeeperParameters `json:"zookeeper,omitempty" tf:"zookeeper,omitempty"`
}

type ClickhouseObservation struct {
}

type ClickhouseParameters struct {

	// +kubebuilder:validation:Optional
	Config []ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// +kubebuilder:validation:Required
	Resources []ResourcesParameters `json:"resources" tf:"resources,omitempty"`
}

type CloudStorageObservation struct {
}

type CloudStorageParameters struct {

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

type CompressionObservation struct {
}

type CompressionParameters struct {

	// +kubebuilder:validation:Required
	Method *string `json:"method" tf:"method,omitempty"`

	// +kubebuilder:validation:Required
	MinPartSize *int64 `json:"minPartSize" tf:"min_part_size,omitempty"`

	// +kubebuilder:validation:Required
	MinPartSizeRatio *float64 `json:"minPartSizeRatio" tf:"min_part_size_ratio,omitempty"`
}

type ConfigObservation struct {
}

type ConfigParameters struct {

	// +kubebuilder:validation:Optional
	BackgroundPoolSize *int64 `json:"backgroundPoolSize,omitempty" tf:"background_pool_size,omitempty"`

	// +kubebuilder:validation:Optional
	BackgroundSchedulePoolSize *int64 `json:"backgroundSchedulePoolSize,omitempty" tf:"background_schedule_pool_size,omitempty"`

	// +kubebuilder:validation:Optional
	Compression []CompressionParameters `json:"compression,omitempty" tf:"compression,omitempty"`

	// +kubebuilder:validation:Optional
	GeobaseURI *string `json:"geobaseUri,omitempty" tf:"geobase_uri,omitempty"`

	// +kubebuilder:validation:Optional
	GraphiteRollup []GraphiteRollupParameters `json:"graphiteRollup,omitempty" tf:"graphite_rollup,omitempty"`

	// +kubebuilder:validation:Optional
	Kafka []KafkaParameters `json:"kafka,omitempty" tf:"kafka,omitempty"`

	// +kubebuilder:validation:Optional
	KafkaTopic []KafkaTopicParameters `json:"kafkaTopic,omitempty" tf:"kafka_topic,omitempty"`

	// +kubebuilder:validation:Optional
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	LogLevel *string `json:"logLevel,omitempty" tf:"log_level,omitempty"`

	// +kubebuilder:validation:Optional
	MarkCacheSize *int64 `json:"markCacheSize,omitempty" tf:"mark_cache_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxConcurrentQueries *int64 `json:"maxConcurrentQueries,omitempty" tf:"max_concurrent_queries,omitempty"`

	// +kubebuilder:validation:Optional
	MaxConnections *int64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// +kubebuilder:validation:Optional
	MaxPartitionSizeToDrop *int64 `json:"maxPartitionSizeToDrop,omitempty" tf:"max_partition_size_to_drop,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTableSizeToDrop *int64 `json:"maxTableSizeToDrop,omitempty" tf:"max_table_size_to_drop,omitempty"`

	// +kubebuilder:validation:Optional
	MergeTree []MergeTreeParameters `json:"mergeTree,omitempty" tf:"merge_tree,omitempty"`

	// +kubebuilder:validation:Optional
	MetricLogEnabled *bool `json:"metricLogEnabled,omitempty" tf:"metric_log_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MetricLogRetentionSize *int64 `json:"metricLogRetentionSize,omitempty" tf:"metric_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	MetricLogRetentionTime *int64 `json:"metricLogRetentionTime,omitempty" tf:"metric_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	PartLogRetentionSize *int64 `json:"partLogRetentionSize,omitempty" tf:"part_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	PartLogRetentionTime *int64 `json:"partLogRetentionTime,omitempty" tf:"part_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	QueryLogRetentionSize *int64 `json:"queryLogRetentionSize,omitempty" tf:"query_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	QueryLogRetentionTime *int64 `json:"queryLogRetentionTime,omitempty" tf:"query_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	QueryThreadLogEnabled *bool `json:"queryThreadLogEnabled,omitempty" tf:"query_thread_log_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	QueryThreadLogRetentionSize *int64 `json:"queryThreadLogRetentionSize,omitempty" tf:"query_thread_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	QueryThreadLogRetentionTime *int64 `json:"queryThreadLogRetentionTime,omitempty" tf:"query_thread_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	Rabbitmq []RabbitmqParameters `json:"rabbitmq,omitempty" tf:"rabbitmq,omitempty"`

	// +kubebuilder:validation:Optional
	TextLogEnabled *bool `json:"textLogEnabled,omitempty" tf:"text_log_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	TextLogLevel *string `json:"textLogLevel,omitempty" tf:"text_log_level,omitempty"`

	// +kubebuilder:validation:Optional
	TextLogRetentionSize *int64 `json:"textLogRetentionSize,omitempty" tf:"text_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	TextLogRetentionTime *int64 `json:"textLogRetentionTime,omitempty" tf:"text_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`

	// +kubebuilder:validation:Optional
	TraceLogEnabled *bool `json:"traceLogEnabled,omitempty" tf:"trace_log_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	TraceLogRetentionSize *int64 `json:"traceLogRetentionSize,omitempty" tf:"trace_log_retention_size,omitempty"`

	// +kubebuilder:validation:Optional
	TraceLogRetentionTime *int64 `json:"traceLogRetentionTime,omitempty" tf:"trace_log_retention_time,omitempty"`

	// +kubebuilder:validation:Optional
	UncompressedCacheSize *int64 `json:"uncompressedCacheSize,omitempty" tf:"uncompressed_cache_size,omitempty"`
}

type DatabaseObservation struct {
}

type DatabaseParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type FormatSchemaObservation struct {
}

type FormatSchemaParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type GraphiteRollupObservation struct {
}

type GraphiteRollupParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Pattern []PatternParameters `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type HostObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type HostParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	ShardName *string `json:"shardName,omitempty" tf:"shard_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// +kubebuilder:validation:Required
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type KafkaObservation struct {
}

type KafkaParameters struct {

	// +kubebuilder:validation:Optional
	SaslMechanism *string `json:"saslMechanism,omitempty" tf:"sasl_mechanism,omitempty"`

	// +kubebuilder:validation:Optional
	SaslPasswordSecretRef *v1.SecretKeySelector `json:"saslPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SaslUsername *string `json:"saslUsername,omitempty" tf:"sasl_username,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityProtocol *string `json:"securityProtocol,omitempty" tf:"security_protocol,omitempty"`
}

type KafkaTopicObservation struct {
}

type KafkaTopicParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Settings []SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`
}

type MaintenanceWindowObservation struct {
}

type MaintenanceWindowParameters struct {

	// +kubebuilder:validation:Optional
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	// +kubebuilder:validation:Optional
	Hour *int64 `json:"hour,omitempty" tf:"hour,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type MergeTreeObservation struct {
}

type MergeTreeParameters struct {

	// +kubebuilder:validation:Optional
	MaxBytesToMergeAtMinSpaceInPool *int64 `json:"maxBytesToMergeAtMinSpaceInPool,omitempty" tf:"max_bytes_to_merge_at_min_space_in_pool,omitempty"`

	// +kubebuilder:validation:Optional
	MaxReplicatedMergesInQueue *int64 `json:"maxReplicatedMergesInQueue,omitempty" tf:"max_replicated_merges_in_queue,omitempty"`

	// +kubebuilder:validation:Optional
	NumberOfFreeEntriesInPoolToLowerMaxSizeOfMerge *int64 `json:"numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge,omitempty" tf:"number_of_free_entries_in_pool_to_lower_max_size_of_merge,omitempty"`

	// +kubebuilder:validation:Optional
	PartsToDelayInsert *int64 `json:"partsToDelayInsert,omitempty" tf:"parts_to_delay_insert,omitempty"`

	// +kubebuilder:validation:Optional
	PartsToThrowInsert *int64 `json:"partsToThrowInsert,omitempty" tf:"parts_to_throw_insert,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicatedDeduplicationWindow *int64 `json:"replicatedDeduplicationWindow,omitempty" tf:"replicated_deduplication_window,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicatedDeduplicationWindowSeconds *int64 `json:"replicatedDeduplicationWindowSeconds,omitempty" tf:"replicated_deduplication_window_seconds,omitempty"`
}

type MlModelObservation struct {
}

type MlModelParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type PatternObservation struct {
}

type PatternParameters struct {

	// +kubebuilder:validation:Required
	Function *string `json:"function" tf:"function,omitempty"`

	// +kubebuilder:validation:Optional
	Regexp *string `json:"regexp,omitempty" tf:"regexp,omitempty"`

	// +kubebuilder:validation:Optional
	Retention []RetentionParameters `json:"retention,omitempty" tf:"retention,omitempty"`
}

type PermissionObservation struct {
}

type PermissionParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`
}

type QuotaObservation struct {
}

type QuotaParameters struct {

	// +kubebuilder:validation:Optional
	Errors *int64 `json:"errors,omitempty" tf:"errors,omitempty"`

	// +kubebuilder:validation:Optional
	ExecutionTime *int64 `json:"executionTime,omitempty" tf:"execution_time,omitempty"`

	// +kubebuilder:validation:Required
	IntervalDuration *int64 `json:"intervalDuration" tf:"interval_duration,omitempty"`

	// +kubebuilder:validation:Optional
	Queries *int64 `json:"queries,omitempty" tf:"queries,omitempty"`

	// +kubebuilder:validation:Optional
	ReadRows *int64 `json:"readRows,omitempty" tf:"read_rows,omitempty"`

	// +kubebuilder:validation:Optional
	ResultRows *int64 `json:"resultRows,omitempty" tf:"result_rows,omitempty"`
}

type RabbitmqObservation struct {
}

type RabbitmqParameters struct {

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type ResourcesObservation struct {
}

type ResourcesParameters struct {

	// +kubebuilder:validation:Required
	DiskSize *int64 `json:"diskSize" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Required
	DiskTypeID *string `json:"diskTypeId" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePresetID *string `json:"resourcePresetId" tf:"resource_preset_id,omitempty"`
}

type RetentionObservation struct {
}

type RetentionParameters struct {

	// +kubebuilder:validation:Required
	Age *int64 `json:"age" tf:"age,omitempty"`

	// +kubebuilder:validation:Required
	Precision *int64 `json:"precision" tf:"precision,omitempty"`
}

type SettingsObservation struct {
}

type SettingsParameters struct {

	// +kubebuilder:validation:Optional
	SaslMechanism *string `json:"saslMechanism,omitempty" tf:"sasl_mechanism,omitempty"`

	// +kubebuilder:validation:Optional
	SaslPasswordSecretRef *v1.SecretKeySelector `json:"saslPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SaslUsername *string `json:"saslUsername,omitempty" tf:"sasl_username,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityProtocol *string `json:"securityProtocol,omitempty" tf:"security_protocol,omitempty"`
}

type ShardGroupObservation struct {
}

type ShardGroupParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ShardNames []*string `json:"shardNames" tf:"shard_names,omitempty"`
}

type UserObservation struct {
}

type UserParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Permission []PermissionParameters `json:"permission,omitempty" tf:"permission,omitempty"`

	// +kubebuilder:validation:Optional
	Quota []QuotaParameters `json:"quota,omitempty" tf:"quota,omitempty"`

	// +kubebuilder:validation:Optional
	Settings []UserSettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`
}

type UserSettingsObservation struct {
}

type UserSettingsParameters struct {

	// +kubebuilder:validation:Optional
	AddHTTPCorsHeader *bool `json:"addHttpCorsHeader,omitempty" tf:"add_http_cors_header,omitempty"`

	// +kubebuilder:validation:Optional
	AllowDdl *bool `json:"allowDdl,omitempty" tf:"allow_ddl,omitempty"`

	// +kubebuilder:validation:Optional
	Compile *bool `json:"compile,omitempty" tf:"compile,omitempty"`

	// +kubebuilder:validation:Optional
	CompileExpressions *bool `json:"compileExpressions,omitempty" tf:"compile_expressions,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectTimeout *int64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	CountDistinctImplementation *string `json:"countDistinctImplementation,omitempty" tf:"count_distinct_implementation,omitempty"`

	// +kubebuilder:validation:Optional
	DistinctOverflowMode *string `json:"distinctOverflowMode,omitempty" tf:"distinct_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	DistributedAggregationMemoryEfficient *bool `json:"distributedAggregationMemoryEfficient,omitempty" tf:"distributed_aggregation_memory_efficient,omitempty"`

	// +kubebuilder:validation:Optional
	DistributedDdlTaskTimeout *int64 `json:"distributedDdlTaskTimeout,omitempty" tf:"distributed_ddl_task_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	DistributedProductMode *string `json:"distributedProductMode,omitempty" tf:"distributed_product_mode,omitempty"`

	// +kubebuilder:validation:Optional
	EmptyResultForAggregationByEmptySet *bool `json:"emptyResultForAggregationByEmptySet,omitempty" tf:"empty_result_for_aggregation_by_empty_set,omitempty"`

	// +kubebuilder:validation:Optional
	EnableHTTPCompression *bool `json:"enableHttpCompression,omitempty" tf:"enable_http_compression,omitempty"`

	// +kubebuilder:validation:Optional
	FallbackToStaleReplicasForDistributedQueries *bool `json:"fallbackToStaleReplicasForDistributedQueries,omitempty" tf:"fallback_to_stale_replicas_for_distributed_queries,omitempty"`

	// +kubebuilder:validation:Optional
	ForceIndexByDate *bool `json:"forceIndexByDate,omitempty" tf:"force_index_by_date,omitempty"`

	// +kubebuilder:validation:Optional
	ForcePrimaryKey *bool `json:"forcePrimaryKey,omitempty" tf:"force_primary_key,omitempty"`

	// +kubebuilder:validation:Optional
	GroupByOverflowMode *string `json:"groupByOverflowMode,omitempty" tf:"group_by_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	GroupByTwoLevelThreshold *int64 `json:"groupByTwoLevelThreshold,omitempty" tf:"group_by_two_level_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	GroupByTwoLevelThresholdBytes *int64 `json:"groupByTwoLevelThresholdBytes,omitempty" tf:"group_by_two_level_threshold_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPConnectionTimeout *int64 `json:"httpConnectionTimeout,omitempty" tf:"http_connection_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHeadersProgressInterval *int64 `json:"httpHeadersProgressInterval,omitempty" tf:"http_headers_progress_interval,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPReceiveTimeout *int64 `json:"httpReceiveTimeout,omitempty" tf:"http_receive_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPSendTimeout *int64 `json:"httpSendTimeout,omitempty" tf:"http_send_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	InputFormatDefaultsForOmittedFields *bool `json:"inputFormatDefaultsForOmittedFields,omitempty" tf:"input_format_defaults_for_omitted_fields,omitempty"`

	// +kubebuilder:validation:Optional
	InputFormatValuesInterpretExpressions *bool `json:"inputFormatValuesInterpretExpressions,omitempty" tf:"input_format_values_interpret_expressions,omitempty"`

	// +kubebuilder:validation:Optional
	InsertQuorum *int64 `json:"insertQuorum,omitempty" tf:"insert_quorum,omitempty"`

	// +kubebuilder:validation:Optional
	InsertQuorumTimeout *int64 `json:"insertQuorumTimeout,omitempty" tf:"insert_quorum_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	JoinOverflowMode *string `json:"joinOverflowMode,omitempty" tf:"join_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	JoinUseNulls *bool `json:"joinUseNulls,omitempty" tf:"join_use_nulls,omitempty"`

	// +kubebuilder:validation:Optional
	JoinedSubqueryRequiresAlias *bool `json:"joinedSubqueryRequiresAlias,omitempty" tf:"joined_subquery_requires_alias,omitempty"`

	// +kubebuilder:validation:Optional
	LowCardinalityAllowInNativeFormat *bool `json:"lowCardinalityAllowInNativeFormat,omitempty" tf:"low_cardinality_allow_in_native_format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAstDepth *int64 `json:"maxAstDepth,omitempty" tf:"max_ast_depth,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAstElements *int64 `json:"maxAstElements,omitempty" tf:"max_ast_elements,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBlockSize *int64 `json:"maxBlockSize,omitempty" tf:"max_block_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesBeforeExternalGroupBy *int64 `json:"maxBytesBeforeExternalGroupBy,omitempty" tf:"max_bytes_before_external_group_by,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesBeforeExternalSort *int64 `json:"maxBytesBeforeExternalSort,omitempty" tf:"max_bytes_before_external_sort,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesInDistinct *int64 `json:"maxBytesInDistinct,omitempty" tf:"max_bytes_in_distinct,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesInJoin *int64 `json:"maxBytesInJoin,omitempty" tf:"max_bytes_in_join,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesInSet *int64 `json:"maxBytesInSet,omitempty" tf:"max_bytes_in_set,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesToRead *int64 `json:"maxBytesToRead,omitempty" tf:"max_bytes_to_read,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesToSort *int64 `json:"maxBytesToSort,omitempty" tf:"max_bytes_to_sort,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBytesToTransfer *int64 `json:"maxBytesToTransfer,omitempty" tf:"max_bytes_to_transfer,omitempty"`

	// +kubebuilder:validation:Optional
	MaxColumnsToRead *int64 `json:"maxColumnsToRead,omitempty" tf:"max_columns_to_read,omitempty"`

	// +kubebuilder:validation:Optional
	MaxExecutionTime *int64 `json:"maxExecutionTime,omitempty" tf:"max_execution_time,omitempty"`

	// +kubebuilder:validation:Optional
	MaxExpandedAstElements *int64 `json:"maxExpandedAstElements,omitempty" tf:"max_expanded_ast_elements,omitempty"`

	// +kubebuilder:validation:Optional
	MaxInsertBlockSize *int64 `json:"maxInsertBlockSize,omitempty" tf:"max_insert_block_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxMemoryUsage *int64 `json:"maxMemoryUsage,omitempty" tf:"max_memory_usage,omitempty"`

	// +kubebuilder:validation:Optional
	MaxMemoryUsageForUser *int64 `json:"maxMemoryUsageForUser,omitempty" tf:"max_memory_usage_for_user,omitempty"`

	// +kubebuilder:validation:Optional
	MaxNetworkBandwidth *int64 `json:"maxNetworkBandwidth,omitempty" tf:"max_network_bandwidth,omitempty"`

	// +kubebuilder:validation:Optional
	MaxNetworkBandwidthForUser *int64 `json:"maxNetworkBandwidthForUser,omitempty" tf:"max_network_bandwidth_for_user,omitempty"`

	// +kubebuilder:validation:Optional
	MaxQuerySize *int64 `json:"maxQuerySize,omitempty" tf:"max_query_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxReplicaDelayForDistributedQueries *int64 `json:"maxReplicaDelayForDistributedQueries,omitempty" tf:"max_replica_delay_for_distributed_queries,omitempty"`

	// +kubebuilder:validation:Optional
	MaxResultBytes *int64 `json:"maxResultBytes,omitempty" tf:"max_result_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	MaxResultRows *int64 `json:"maxResultRows,omitempty" tf:"max_result_rows,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsInDistinct *int64 `json:"maxRowsInDistinct,omitempty" tf:"max_rows_in_distinct,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsInJoin *int64 `json:"maxRowsInJoin,omitempty" tf:"max_rows_in_join,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsInSet *int64 `json:"maxRowsInSet,omitempty" tf:"max_rows_in_set,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsToGroupBy *int64 `json:"maxRowsToGroupBy,omitempty" tf:"max_rows_to_group_by,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsToRead *int64 `json:"maxRowsToRead,omitempty" tf:"max_rows_to_read,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsToSort *int64 `json:"maxRowsToSort,omitempty" tf:"max_rows_to_sort,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRowsToTransfer *int64 `json:"maxRowsToTransfer,omitempty" tf:"max_rows_to_transfer,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTemporaryColumns *int64 `json:"maxTemporaryColumns,omitempty" tf:"max_temporary_columns,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTemporaryNonConstColumns *int64 `json:"maxTemporaryNonConstColumns,omitempty" tf:"max_temporary_non_const_columns,omitempty"`

	// +kubebuilder:validation:Optional
	MaxThreads *int64 `json:"maxThreads,omitempty" tf:"max_threads,omitempty"`

	// +kubebuilder:validation:Optional
	MergeTreeMaxBytesToUseCache *int64 `json:"mergeTreeMaxBytesToUseCache,omitempty" tf:"merge_tree_max_bytes_to_use_cache,omitempty"`

	// +kubebuilder:validation:Optional
	MergeTreeMaxRowsToUseCache *int64 `json:"mergeTreeMaxRowsToUseCache,omitempty" tf:"merge_tree_max_rows_to_use_cache,omitempty"`

	// +kubebuilder:validation:Optional
	MergeTreeMinBytesForConcurrentRead *int64 `json:"mergeTreeMinBytesForConcurrentRead,omitempty" tf:"merge_tree_min_bytes_for_concurrent_read,omitempty"`

	// +kubebuilder:validation:Optional
	MergeTreeMinRowsForConcurrentRead *int64 `json:"mergeTreeMinRowsForConcurrentRead,omitempty" tf:"merge_tree_min_rows_for_concurrent_read,omitempty"`

	// +kubebuilder:validation:Optional
	MinBytesToUseDirectIo *int64 `json:"minBytesToUseDirectIo,omitempty" tf:"min_bytes_to_use_direct_io,omitempty"`

	// +kubebuilder:validation:Optional
	MinCountToCompile *int64 `json:"minCountToCompile,omitempty" tf:"min_count_to_compile,omitempty"`

	// +kubebuilder:validation:Optional
	MinCountToCompileExpression *int64 `json:"minCountToCompileExpression,omitempty" tf:"min_count_to_compile_expression,omitempty"`

	// +kubebuilder:validation:Optional
	MinExecutionSpeed *int64 `json:"minExecutionSpeed,omitempty" tf:"min_execution_speed,omitempty"`

	// +kubebuilder:validation:Optional
	MinExecutionSpeedBytes *int64 `json:"minExecutionSpeedBytes,omitempty" tf:"min_execution_speed_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	MinInsertBlockSizeBytes *int64 `json:"minInsertBlockSizeBytes,omitempty" tf:"min_insert_block_size_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	MinInsertBlockSizeRows *int64 `json:"minInsertBlockSizeRows,omitempty" tf:"min_insert_block_size_rows,omitempty"`

	// +kubebuilder:validation:Optional
	OutputFormatJSONQuote64BitIntegers *bool `json:"outputFormatJsonQuote64BitIntegers,omitempty" tf:"output_format_json_quote_64bit_integers,omitempty"`

	// +kubebuilder:validation:Optional
	OutputFormatJSONQuoteDenormals *bool `json:"outputFormatJsonQuoteDenormals,omitempty" tf:"output_format_json_quote_denormals,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	QuotaMode *string `json:"quotaMode,omitempty" tf:"quota_mode,omitempty"`

	// +kubebuilder:validation:Optional
	ReadOverflowMode *string `json:"readOverflowMode,omitempty" tf:"read_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Readonly *int64 `json:"readonly,omitempty" tf:"readonly,omitempty"`

	// +kubebuilder:validation:Optional
	ReceiveTimeout *int64 `json:"receiveTimeout,omitempty" tf:"receive_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationAlterPartitionsSync *int64 `json:"replicationAlterPartitionsSync,omitempty" tf:"replication_alter_partitions_sync,omitempty"`

	// +kubebuilder:validation:Optional
	ResultOverflowMode *string `json:"resultOverflowMode,omitempty" tf:"result_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	SelectSequentialConsistency *bool `json:"selectSequentialConsistency,omitempty" tf:"select_sequential_consistency,omitempty"`

	// +kubebuilder:validation:Optional
	SendProgressInHTTPHeaders *bool `json:"sendProgressInHttpHeaders,omitempty" tf:"send_progress_in_http_headers,omitempty"`

	// +kubebuilder:validation:Optional
	SendTimeout *int64 `json:"sendTimeout,omitempty" tf:"send_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SetOverflowMode *string `json:"setOverflowMode,omitempty" tf:"set_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	SkipUnavailableShards *bool `json:"skipUnavailableShards,omitempty" tf:"skip_unavailable_shards,omitempty"`

	// +kubebuilder:validation:Optional
	SortOverflowMode *string `json:"sortOverflowMode,omitempty" tf:"sort_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	TimeoutOverflowMode *string `json:"timeoutOverflowMode,omitempty" tf:"timeout_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	TransferOverflowMode *string `json:"transferOverflowMode,omitempty" tf:"transfer_overflow_mode,omitempty"`

	// +kubebuilder:validation:Optional
	TransformNullIn *bool `json:"transformNullIn,omitempty" tf:"transform_null_in,omitempty"`

	// +kubebuilder:validation:Optional
	UseUncompressedCache *bool `json:"useUncompressedCache,omitempty" tf:"use_uncompressed_cache,omitempty"`
}

type ZookeeperObservation struct {
}

type ZookeeperParameters struct {

	// +kubebuilder:validation:Optional
	Resources []ZookeeperResourcesParameters `json:"resources,omitempty" tf:"resources,omitempty"`
}

type ZookeeperResourcesObservation struct {
}

type ZookeeperResourcesParameters struct {

	// +kubebuilder:validation:Optional
	DiskSize *int64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskTypeID *string `json:"diskTypeId,omitempty" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcePresetID *string `json:"resourcePresetId,omitempty" tf:"resource_preset_id,omitempty"`
}

// ClickhouseClusterSpec defines the desired state of ClickhouseCluster
type ClickhouseClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClickhouseClusterParameters `json:"forProvider"`
}

// ClickhouseClusterStatus defines the observed state of ClickhouseCluster.
type ClickhouseClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClickhouseClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ClickhouseCluster is the Schema for the ClickhouseClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type ClickhouseCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClickhouseClusterSpec   `json:"spec"`
	Status            ClickhouseClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClickhouseClusterList contains a list of ClickhouseClusters
type ClickhouseClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClickhouseCluster `json:"items"`
}

// Repository type metadata.
var (
	ClickhouseCluster_Kind             = "ClickhouseCluster"
	ClickhouseCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClickhouseCluster_Kind}.String()
	ClickhouseCluster_KindAPIVersion   = ClickhouseCluster_Kind + "." + CRDGroupVersion.String()
	ClickhouseCluster_GroupVersionKind = CRDGroupVersion.WithKind(ClickhouseCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&ClickhouseCluster{}, &ClickhouseClusterList{})
}
