/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigKafkaObservation struct {
}

type ConfigKafkaParameters struct {

	// +kubebuilder:validation:Optional
	KafkaConfig []KafkaConfigParameters `json:"kafkaConfig,omitempty" tf:"kafka_config,omitempty"`

	// +kubebuilder:validation:Required
	Resources []KafkaResourcesParameters `json:"resources" tf:"resources,omitempty"`
}

type ConfigZookeeperObservation struct {
}

type ConfigZookeeperParameters struct {

	// +kubebuilder:validation:Optional
	Resources []ConfigZookeeperResourcesParameters `json:"resources,omitempty" tf:"resources,omitempty"`
}

type ConfigZookeeperResourcesObservation struct {
}

type ConfigZookeeperResourcesParameters struct {

	// +kubebuilder:validation:Optional
	DiskSize *int64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskTypeID *string `json:"diskTypeId,omitempty" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcePresetID *string `json:"resourcePresetId,omitempty" tf:"resource_preset_id,omitempty"`
}

type KafkaClusterConfigObservation struct {
}

type KafkaClusterConfigParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	BrokersCount *int64 `json:"brokersCount,omitempty" tf:"brokers_count,omitempty"`

	// +kubebuilder:validation:Required
	Kafka []ConfigKafkaParameters `json:"kafka" tf:"kafka,omitempty"`

	// +kubebuilder:validation:Optional
	SchemaRegistry *bool `json:"schemaRegistry,omitempty" tf:"schema_registry,omitempty"`

	// +kubebuilder:validation:Optional
	UnmanagedTopics *bool `json:"unmanagedTopics,omitempty" tf:"unmanaged_topics,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`

	// +kubebuilder:validation:Required
	Zones []*string `json:"zones" tf:"zones,omitempty"`

	// +kubebuilder:validation:Optional
	Zookeeper []ConfigZookeeperParameters `json:"zookeeper,omitempty" tf:"zookeeper,omitempty"`
}

type KafkaClusterHostObservation struct {
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type KafkaClusterHostParameters struct {
}

type KafkaClusterObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	Host []KafkaClusterHostObservation `json:"host,omitempty" tf:"host,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type KafkaClusterParameters struct {

	// +kubebuilder:validation:Required
	Config []KafkaClusterConfigParameters `json:"config" tf:"config,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	HostGroupIds []*string `json:"hostGroupIds,omitempty" tf:"host_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Topic []TopicParameters `json:"topic,omitempty" tf:"topic,omitempty"`

	// +kubebuilder:validation:Optional
	User []KafkaClusterUserParameters `json:"user,omitempty" tf:"user,omitempty"`
}

type KafkaClusterUserObservation struct {
}

type KafkaClusterUserParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Permission []UserPermissionParameters `json:"permission,omitempty" tf:"permission,omitempty"`
}

type KafkaConfigObservation struct {
}

type KafkaConfigParameters struct {

	// +kubebuilder:validation:Optional
	AutoCreateTopicsEnable *bool `json:"autoCreateTopicsEnable,omitempty" tf:"auto_create_topics_enable,omitempty"`

	// +kubebuilder:validation:Optional
	CompressionType *string `json:"compressionType,omitempty" tf:"compression_type,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultReplicationFactor *string `json:"defaultReplicationFactor,omitempty" tf:"default_replication_factor,omitempty"`

	// +kubebuilder:validation:Optional
	LogFlushIntervalMessages *string `json:"logFlushIntervalMessages,omitempty" tf:"log_flush_interval_messages,omitempty"`

	// +kubebuilder:validation:Optional
	LogFlushIntervalMs *string `json:"logFlushIntervalMs,omitempty" tf:"log_flush_interval_ms,omitempty"`

	// +kubebuilder:validation:Optional
	LogFlushSchedulerIntervalMs *string `json:"logFlushSchedulerIntervalMs,omitempty" tf:"log_flush_scheduler_interval_ms,omitempty"`

	// +kubebuilder:validation:Optional
	LogPreallocate *bool `json:"logPreallocate,omitempty" tf:"log_preallocate,omitempty"`

	// +kubebuilder:validation:Optional
	LogRetentionBytes *string `json:"logRetentionBytes,omitempty" tf:"log_retention_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	LogRetentionHours *string `json:"logRetentionHours,omitempty" tf:"log_retention_hours,omitempty"`

	// +kubebuilder:validation:Optional
	LogRetentionMinutes *string `json:"logRetentionMinutes,omitempty" tf:"log_retention_minutes,omitempty"`

	// +kubebuilder:validation:Optional
	LogRetentionMs *string `json:"logRetentionMs,omitempty" tf:"log_retention_ms,omitempty"`

	// +kubebuilder:validation:Optional
	LogSegmentBytes *string `json:"logSegmentBytes,omitempty" tf:"log_segment_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	NumPartitions *string `json:"numPartitions,omitempty" tf:"num_partitions,omitempty"`

	// +kubebuilder:validation:Optional
	SocketReceiveBufferBytes *string `json:"socketReceiveBufferBytes,omitempty" tf:"socket_receive_buffer_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	SocketSendBufferBytes *string `json:"socketSendBufferBytes,omitempty" tf:"socket_send_buffer_bytes,omitempty"`
}

type KafkaResourcesObservation struct {
}

type KafkaResourcesParameters struct {

	// +kubebuilder:validation:Required
	DiskSize *int64 `json:"diskSize" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Required
	DiskTypeID *string `json:"diskTypeId" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePresetID *string `json:"resourcePresetId" tf:"resource_preset_id,omitempty"`
}

type TopicConfigObservation struct {
}

type TopicConfigParameters struct {

	// +kubebuilder:validation:Optional
	CleanupPolicy *string `json:"cleanupPolicy,omitempty" tf:"cleanup_policy,omitempty"`

	// +kubebuilder:validation:Optional
	CompressionType *string `json:"compressionType,omitempty" tf:"compression_type,omitempty"`

	// +kubebuilder:validation:Optional
	DeleteRetentionMs *string `json:"deleteRetentionMs,omitempty" tf:"delete_retention_ms,omitempty"`

	// +kubebuilder:validation:Optional
	FileDeleteDelayMs *string `json:"fileDeleteDelayMs,omitempty" tf:"file_delete_delay_ms,omitempty"`

	// +kubebuilder:validation:Optional
	FlushMessages *string `json:"flushMessages,omitempty" tf:"flush_messages,omitempty"`

	// +kubebuilder:validation:Optional
	FlushMs *string `json:"flushMs,omitempty" tf:"flush_ms,omitempty"`

	// +kubebuilder:validation:Optional
	MaxMessageBytes *string `json:"maxMessageBytes,omitempty" tf:"max_message_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	MinCompactionLagMs *string `json:"minCompactionLagMs,omitempty" tf:"min_compaction_lag_ms,omitempty"`

	// +kubebuilder:validation:Optional
	MinInsyncReplicas *string `json:"minInsyncReplicas,omitempty" tf:"min_insync_replicas,omitempty"`

	// +kubebuilder:validation:Optional
	Preallocate *bool `json:"preallocate,omitempty" tf:"preallocate,omitempty"`

	// +kubebuilder:validation:Optional
	RetentionBytes *string `json:"retentionBytes,omitempty" tf:"retention_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	RetentionMs *string `json:"retentionMs,omitempty" tf:"retention_ms,omitempty"`

	// +kubebuilder:validation:Optional
	SegmentBytes *string `json:"segmentBytes,omitempty" tf:"segment_bytes,omitempty"`
}

type TopicObservation struct {
}

type TopicParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Partitions *int64 `json:"partitions" tf:"partitions,omitempty"`

	// +kubebuilder:validation:Required
	ReplicationFactor *int64 `json:"replicationFactor" tf:"replication_factor,omitempty"`

	// +kubebuilder:validation:Optional
	TopicConfig []TopicConfigParameters `json:"topicConfig,omitempty" tf:"topic_config,omitempty"`
}

type UserPermissionObservation struct {
}

type UserPermissionParameters struct {

	// +kubebuilder:validation:Required
	Role *string `json:"role" tf:"role,omitempty"`

	// +kubebuilder:validation:Required
	TopicName *string `json:"topicName" tf:"topic_name,omitempty"`
}

// KafkaClusterSpec defines the desired state of KafkaCluster
type KafkaClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KafkaClusterParameters `json:"forProvider"`
}

// KafkaClusterStatus defines the observed state of KafkaCluster.
type KafkaClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KafkaClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// KafkaCluster is the Schema for the KafkaClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type KafkaCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KafkaClusterSpec   `json:"spec"`
	Status            KafkaClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KafkaClusterList contains a list of KafkaClusters
type KafkaClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KafkaCluster `json:"items"`
}

// Repository type metadata.
var (
	KafkaCluster_Kind             = "KafkaCluster"
	KafkaCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KafkaCluster_Kind}.String()
	KafkaCluster_KindAPIVersion   = KafkaCluster_Kind + "." + CRDGroupVersion.String()
	KafkaCluster_GroupVersionKind = CRDGroupVersion.WithKind(KafkaCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&KafkaCluster{}, &KafkaClusterList{})
}
