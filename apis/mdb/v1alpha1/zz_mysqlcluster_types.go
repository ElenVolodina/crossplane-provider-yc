/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConnectionLimitsObservation struct {
}

type ConnectionLimitsParameters struct {

	// +kubebuilder:validation:Optional
	MaxConnectionsPerHour *int64 `json:"maxConnectionsPerHour,omitempty" tf:"max_connections_per_hour,omitempty"`

	// +kubebuilder:validation:Optional
	MaxQuestionsPerHour *int64 `json:"maxQuestionsPerHour,omitempty" tf:"max_questions_per_hour,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUpdatesPerHour *int64 `json:"maxUpdatesPerHour,omitempty" tf:"max_updates_per_hour,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUserConnections *int64 `json:"maxUserConnections,omitempty" tf:"max_user_connections,omitempty"`
}

type MysqlClusterAccessObservation struct {
}

type MysqlClusterAccessParameters struct {

	// +kubebuilder:validation:Optional
	DataLens *bool `json:"dataLens,omitempty" tf:"data_lens,omitempty"`

	// +kubebuilder:validation:Optional
	WebSQL *bool `json:"webSql,omitempty" tf:"web_sql,omitempty"`
}

type MysqlClusterBackupWindowStartObservation struct {
}

type MysqlClusterBackupWindowStartParameters struct {

	// +kubebuilder:validation:Optional
	Hours *int64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// +kubebuilder:validation:Optional
	Minutes *int64 `json:"minutes,omitempty" tf:"minutes,omitempty"`
}

type MysqlClusterDatabaseObservation struct {
}

type MysqlClusterDatabaseParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type MysqlClusterHostObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	ReplicationSource *string `json:"replicationSource,omitempty" tf:"replication_source,omitempty"`
}

type MysqlClusterHostParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationSourceName *string `json:"replicationSourceName,omitempty" tf:"replication_source_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Required
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type MysqlClusterMaintenanceWindowObservation struct {
}

type MysqlClusterMaintenanceWindowParameters struct {

	// +kubebuilder:validation:Optional
	Day *string `json:"day,omitempty" tf:"day,omitempty"`

	// +kubebuilder:validation:Optional
	Hour *int64 `json:"hour,omitempty" tf:"hour,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type MysqlClusterObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type MysqlClusterParameters struct {

	// +kubebuilder:validation:Optional
	Access []MysqlClusterAccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// +kubebuilder:validation:Optional
	AllowRegenerationHost *bool `json:"allowRegenerationHost,omitempty" tf:"allow_regeneration_host,omitempty"`

	// +kubebuilder:validation:Optional
	BackupWindowStart []MysqlClusterBackupWindowStartParameters `json:"backupWindowStart,omitempty" tf:"backup_window_start,omitempty"`

	// +kubebuilder:validation:Required
	Database []MysqlClusterDatabaseParameters `json:"database" tf:"database,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Environment *string `json:"environment" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Required
	Host []MysqlClusterHostParameters `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MaintenanceWindow []MysqlClusterMaintenanceWindowParameters `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// +kubebuilder:validation:Optional
	MysqlConfig map[string]*string `json:"mysqlConfig,omitempty" tf:"mysql_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Required
	Resources []MysqlClusterResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// +kubebuilder:validation:Optional
	Restore []RestoreParameters `json:"restore,omitempty" tf:"restore,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Required
	User []MysqlClusterUserParameters `json:"user" tf:"user,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type MysqlClusterResourcesObservation struct {
}

type MysqlClusterResourcesParameters struct {

	// +kubebuilder:validation:Required
	DiskSize *int64 `json:"diskSize" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Required
	DiskTypeID *string `json:"diskTypeId" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePresetID *string `json:"resourcePresetId" tf:"resource_preset_id,omitempty"`
}

type MysqlClusterUserObservation struct {
}

type MysqlClusterUserParameters struct {

	// +kubebuilder:validation:Optional
	AuthenticationPlugin *string `json:"authenticationPlugin,omitempty" tf:"authentication_plugin,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectionLimits []ConnectionLimitsParameters `json:"connectionLimits,omitempty" tf:"connection_limits,omitempty"`

	// +kubebuilder:validation:Optional
	GlobalPermissions []*string `json:"globalPermissions,omitempty" tf:"global_permissions,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Permission []MysqlClusterUserPermissionParameters `json:"permission,omitempty" tf:"permission,omitempty"`
}

type MysqlClusterUserPermissionObservation struct {
}

type MysqlClusterUserPermissionParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`

	// +kubebuilder:validation:Optional
	Roles []*string `json:"roles,omitempty" tf:"roles,omitempty"`
}

type RestoreObservation struct {
}

type RestoreParameters struct {

	// +kubebuilder:validation:Required
	BackupID *string `json:"backupId" tf:"backup_id,omitempty"`

	// +kubebuilder:validation:Optional
	Time *string `json:"time,omitempty" tf:"time,omitempty"`
}

// MysqlClusterSpec defines the desired state of MysqlCluster
type MysqlClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MysqlClusterParameters `json:"forProvider"`
}

// MysqlClusterStatus defines the observed state of MysqlCluster.
type MysqlClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MysqlClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MysqlCluster is the Schema for the MysqlClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type MysqlCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MysqlClusterSpec   `json:"spec"`
	Status            MysqlClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MysqlClusterList contains a list of MysqlClusters
type MysqlClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MysqlCluster `json:"items"`
}

// Repository type metadata.
var (
	MysqlCluster_Kind             = "MysqlCluster"
	MysqlCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MysqlCluster_Kind}.String()
	MysqlCluster_KindAPIVersion   = MysqlCluster_Kind + "." + CRDGroupVersion.String()
	MysqlCluster_GroupVersionKind = CRDGroupVersion.WithKind(MysqlCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&MysqlCluster{}, &MysqlClusterList{})
}
