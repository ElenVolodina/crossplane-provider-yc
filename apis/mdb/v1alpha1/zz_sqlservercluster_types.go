/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type SqlserverClusterBackupWindowStartObservation struct {
}

type SqlserverClusterBackupWindowStartParameters struct {

	// +kubebuilder:validation:Optional
	Hours *int64 `json:"hours,omitempty" tf:"hours,omitempty"`

	// +kubebuilder:validation:Optional
	Minutes *int64 `json:"minutes,omitempty" tf:"minutes,omitempty"`
}

type SqlserverClusterDatabaseObservation struct {
}

type SqlserverClusterDatabaseParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type SqlserverClusterHostObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type SqlserverClusterHostParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Required
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type SqlserverClusterObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type SqlserverClusterParameters struct {

	// +kubebuilder:validation:Optional
	BackupWindowStart []SqlserverClusterBackupWindowStartParameters `json:"backupWindowStart,omitempty" tf:"backup_window_start,omitempty"`

	// +kubebuilder:validation:Required
	Database []SqlserverClusterDatabaseParameters `json:"database" tf:"database,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Environment *string `json:"environment" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Required
	Host []SqlserverClusterHostParameters `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Required
	Resources []SqlserverClusterResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	SqlserverConfig map[string]*string `json:"sqlserverConfig,omitempty" tf:"sqlserver_config,omitempty"`

	// +kubebuilder:validation:Required
	User []SqlserverClusterUserParameters `json:"user" tf:"user,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type SqlserverClusterResourcesObservation struct {
}

type SqlserverClusterResourcesParameters struct {

	// +kubebuilder:validation:Required
	DiskSize *int64 `json:"diskSize" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Required
	DiskTypeID *string `json:"diskTypeId" tf:"disk_type_id,omitempty"`

	// +kubebuilder:validation:Required
	ResourcePresetID *string `json:"resourcePresetId" tf:"resource_preset_id,omitempty"`
}

type SqlserverClusterUserObservation struct {
}

type SqlserverClusterUserParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Permission []SqlserverClusterUserPermissionParameters `json:"permission,omitempty" tf:"permission,omitempty"`
}

type SqlserverClusterUserPermissionObservation struct {
}

type SqlserverClusterUserPermissionParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`

	// +kubebuilder:validation:Optional
	Roles []*string `json:"roles,omitempty" tf:"roles,omitempty"`
}

// SqlserverClusterSpec defines the desired state of SqlserverCluster
type SqlserverClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SqlserverClusterParameters `json:"forProvider"`
}

// SqlserverClusterStatus defines the observed state of SqlserverCluster.
type SqlserverClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SqlserverClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SqlserverCluster is the Schema for the SqlserverClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type SqlserverCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SqlserverClusterSpec   `json:"spec"`
	Status            SqlserverClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SqlserverClusterList contains a list of SqlserverClusters
type SqlserverClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SqlserverCluster `json:"items"`
}

// Repository type metadata.
var (
	SqlserverCluster_Kind             = "SqlserverCluster"
	SqlserverCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SqlserverCluster_Kind}.String()
	SqlserverCluster_KindAPIVersion   = SqlserverCluster_Kind + "." + CRDGroupVersion.String()
	SqlserverCluster_GroupVersionKind = CRDGroupVersion.WithKind(SqlserverCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&SqlserverCluster{}, &SqlserverClusterList{})
}
