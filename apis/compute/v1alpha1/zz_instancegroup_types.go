/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AllocationPolicyObservation struct {
}

type AllocationPolicyParameters struct {

	// +kubebuilder:validation:Required
	Zones []*string `json:"zones" tf:"zones,omitempty"`
}

type ApplicationLoadBalancerObservation struct {
	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`
}

type ApplicationLoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	MaxOpeningTrafficDuration *int64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type AutoScaleObservation struct {
}

type AutoScaleParameters struct {

	// +kubebuilder:validation:Optional
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// +kubebuilder:validation:Optional
	CustomRule []CustomRuleParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// +kubebuilder:validation:Required
	InitialSize *int64 `json:"initialSize" tf:"initial_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Required
	MeasurementDuration *int64 `json:"measurementDuration" tf:"measurement_duration,omitempty"`

	// +kubebuilder:validation:Optional
	MinZoneSize *int64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// +kubebuilder:validation:Optional
	StabilizationDuration *int64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// +kubebuilder:validation:Optional
	WarmupDuration *int64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

type BootDiskInitializeParamsObservation struct {
}

type BootDiskInitializeParamsParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	Size *int64 `json:"size,omitempty" tf:"size,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomRuleObservation struct {
}

type CustomRuleParameters struct {

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	MetricType *string `json:"metricType" tf:"metric_type,omitempty"`

	// +kubebuilder:validation:Required
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// +kubebuilder:validation:Required
	Target *float64 `json:"target" tf:"target,omitempty"`
}

type DeployPolicyObservation struct {
}

type DeployPolicyParameters struct {

	// +kubebuilder:validation:Optional
	MaxCreating *int64 `json:"maxCreating,omitempty" tf:"max_creating,omitempty"`

	// +kubebuilder:validation:Optional
	MaxDeleting *int64 `json:"maxDeleting,omitempty" tf:"max_deleting,omitempty"`

	// +kubebuilder:validation:Required
	MaxExpansion *int64 `json:"maxExpansion" tf:"max_expansion,omitempty"`

	// +kubebuilder:validation:Required
	MaxUnavailable *int64 `json:"maxUnavailable" tf:"max_unavailable,omitempty"`

	// +kubebuilder:validation:Optional
	StartupDuration *int64 `json:"startupDuration,omitempty" tf:"startup_duration,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type FixedScaleObservation struct {
}

type FixedScaleParameters struct {

	// +kubebuilder:validation:Required
	Size *int64 `json:"size" tf:"size,omitempty"`
}

type HTTPOptionsObservation struct {
}

type HTTPOptionsParameters struct {

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`
}

type HealthCheckObservation struct {
}

type HealthCheckParameters struct {

	// +kubebuilder:validation:Optional
	HTTPOptions []HTTPOptionsParameters `json:"httpOptions,omitempty" tf:"http_options,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	Interval *int64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	TCPOptions []TCPOptionsParameters `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type InstanceGroupObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	Instances []InstancesObservation `json:"instances,omitempty" tf:"instances,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type InstanceGroupParameters struct {

	// +kubebuilder:validation:Required
	AllocationPolicy []AllocationPolicyParameters `json:"allocationPolicy" tf:"allocation_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationLoadBalancer []ApplicationLoadBalancerParameters `json:"applicationLoadBalancer,omitempty" tf:"application_load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Required
	DeployPolicy []DeployPolicyParameters `json:"deployPolicy" tf:"deploy_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// +kubebuilder:validation:Required
	InstanceTemplate []InstanceTemplateParameters `json:"instanceTemplate" tf:"instance_template,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	MaxCheckingHealthDuration *int64 `json:"maxCheckingHealthDuration,omitempty" tf:"max_checking_health_duration,omitempty"`

	// +kubebuilder:validation:Required
	ScalePolicy []ScalePolicyParameters `json:"scalePolicy" tf:"scale_policy,omitempty"`

	// +kubebuilder:validation:Required
	ServiceAccountID *string `json:"serviceAccountId" tf:"service_account_id,omitempty"`

	// +kubebuilder:validation:Optional
	Variables map[string]*string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type InstanceTemplateBootDiskObservation struct {
}

type InstanceTemplateBootDiskParameters struct {

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// +kubebuilder:validation:Optional
	InitializeParams []BootDiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InstanceTemplateNetworkInterfaceObservation struct {
}

type InstanceTemplateNetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	DNSRecord []NetworkInterfaceDNSRecordParameters `json:"dnsRecord,omitempty" tf:"dns_record,omitempty"`

	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6DNSRecord []NetworkInterfaceIPv6DNSRecordParameters `json:"ipv6DnsRecord,omitempty" tf:"ipv6_dns_record,omitempty"`

	// +kubebuilder:validation:Optional
	Nat *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	// +kubebuilder:validation:Optional
	NatDNSRecord []NetworkInterfaceNatDNSRecordParameters `json:"natDnsRecord,omitempty" tf:"nat_dns_record,omitempty"`

	// +kubebuilder:validation:Optional
	NatIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`
}

type InstanceTemplateObservation struct {
}

type InstanceTemplateParameters struct {

	// +kubebuilder:validation:Required
	BootDisk []InstanceTemplateBootDiskParameters `json:"bootDisk" tf:"boot_disk,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkInterface []InstanceTemplateNetworkInterfaceParameters `json:"networkInterface" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkSettings []NetworkSettingsParameters `json:"networkSettings,omitempty" tf:"network_settings,omitempty"`

	// +kubebuilder:validation:Optional
	PlacementPolicy []InstanceTemplatePlacementPolicyParameters `json:"placementPolicy,omitempty" tf:"placement_policy,omitempty"`

	// +kubebuilder:validation:Optional
	PlatformID *string `json:"platformId,omitempty" tf:"platform_id,omitempty"`

	// +kubebuilder:validation:Required
	Resources []InstanceTemplateResourcesParameters `json:"resources" tf:"resources,omitempty"`

	// +kubebuilder:validation:Optional
	SchedulingPolicy []InstanceTemplateSchedulingPolicyParameters `json:"schedulingPolicy,omitempty" tf:"scheduling_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecondaryDisk []InstanceTemplateSecondaryDiskParameters `json:"secondaryDisk,omitempty" tf:"secondary_disk,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`
}

type InstanceTemplatePlacementPolicyObservation struct {
}

type InstanceTemplatePlacementPolicyParameters struct {

	// +kubebuilder:validation:Required
	PlacementGroupID *string `json:"placementGroupId" tf:"placement_group_id,omitempty"`
}

type InstanceTemplateResourcesObservation struct {
}

type InstanceTemplateResourcesParameters struct {

	// +kubebuilder:validation:Optional
	CoreFraction *int64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

	// +kubebuilder:validation:Required
	Cores *int64 `json:"cores" tf:"cores,omitempty"`

	// +kubebuilder:validation:Optional
	Gpus *int64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	// +kubebuilder:validation:Required
	Memory *float64 `json:"memory" tf:"memory,omitempty"`
}

type InstanceTemplateSchedulingPolicyObservation struct {
}

type InstanceTemplateSchedulingPolicyParameters struct {

	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
}

type InstanceTemplateSecondaryDiskObservation struct {
}

type InstanceTemplateSecondaryDiskParameters struct {

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	DiskID *string `json:"diskId,omitempty" tf:"disk_id,omitempty"`

	// +kubebuilder:validation:Optional
	InitializeParams []SecondaryDiskInitializeParamsParameters `json:"initializeParams,omitempty" tf:"initialize_params,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type InstancesNetworkInterfaceObservation struct {
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	IPv4 *bool `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	Index *int64 `json:"index,omitempty" tf:"index,omitempty"`

	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	Nat *bool `json:"nat,omitempty" tf:"nat,omitempty"`

	NatIPAddress *string `json:"natIpAddress,omitempty" tf:"nat_ip_address,omitempty"`

	NatIPVersion *string `json:"natIpVersion,omitempty" tf:"nat_ip_version,omitempty"`

	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type InstancesNetworkInterfaceParameters struct {
}

type InstancesObservation struct {
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`

	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkInterface []InstancesNetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusChangedAt *string `json:"statusChangedAt,omitempty" tf:"status_changed_at,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type InstancesParameters struct {
}

type LoadBalancerObservation struct {
	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`

	TargetGroupID *string `json:"targetGroupId,omitempty" tf:"target_group_id,omitempty"`
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	MaxOpeningTrafficDuration *int64 `json:"maxOpeningTrafficDuration,omitempty" tf:"max_opening_traffic_duration,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupDescription *string `json:"targetGroupDescription,omitempty" tf:"target_group_description,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupLabels map[string]*string `json:"targetGroupLabels,omitempty" tf:"target_group_labels,omitempty"`

	// +kubebuilder:validation:Optional
	TargetGroupName *string `json:"targetGroupName,omitempty" tf:"target_group_name,omitempty"`
}

type NetworkInterfaceDNSRecordObservation struct {
}

type NetworkInterfaceDNSRecordParameters struct {

	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// +kubebuilder:validation:Required
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// +kubebuilder:validation:Optional
	TTL *int64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceIPv6DNSRecordObservation struct {
}

type NetworkInterfaceIPv6DNSRecordParameters struct {

	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// +kubebuilder:validation:Required
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// +kubebuilder:validation:Optional
	TTL *int64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkInterfaceNatDNSRecordObservation struct {
}

type NetworkInterfaceNatDNSRecordParameters struct {

	// +kubebuilder:validation:Optional
	DNSZoneID *string `json:"dnsZoneId,omitempty" tf:"dns_zone_id,omitempty"`

	// +kubebuilder:validation:Required
	Fqdn *string `json:"fqdn" tf:"fqdn,omitempty"`

	// +kubebuilder:validation:Optional
	Ptr *bool `json:"ptr,omitempty" tf:"ptr,omitempty"`

	// +kubebuilder:validation:Optional
	TTL *int64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type NetworkSettingsObservation struct {
}

type NetworkSettingsParameters struct {

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalePolicyObservation struct {
}

type ScalePolicyParameters struct {

	// +kubebuilder:validation:Optional
	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// +kubebuilder:validation:Optional
	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`

	// +kubebuilder:validation:Optional
	TestAutoScale []TestAutoScaleParameters `json:"testAutoScale,omitempty" tf:"test_auto_scale,omitempty"`
}

type SecondaryDiskInitializeParamsObservation struct {
}

type SecondaryDiskInitializeParamsParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	Size *int64 `json:"size,omitempty" tf:"size,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TCPOptionsObservation struct {
}

type TCPOptionsParameters struct {

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`
}

type TestAutoScaleCustomRuleObservation struct {
}

type TestAutoScaleCustomRuleParameters struct {

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Required
	MetricType *string `json:"metricType" tf:"metric_type,omitempty"`

	// +kubebuilder:validation:Required
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	// +kubebuilder:validation:Required
	Target *float64 `json:"target" tf:"target,omitempty"`
}

type TestAutoScaleObservation struct {
}

type TestAutoScaleParameters struct {

	// +kubebuilder:validation:Optional
	CPUUtilizationTarget *float64 `json:"cpuUtilizationTarget,omitempty" tf:"cpu_utilization_target,omitempty"`

	// +kubebuilder:validation:Optional
	CustomRule []TestAutoScaleCustomRuleParameters `json:"customRule,omitempty" tf:"custom_rule,omitempty"`

	// +kubebuilder:validation:Required
	InitialSize *int64 `json:"initialSize" tf:"initial_size,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *int64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Required
	MeasurementDuration *int64 `json:"measurementDuration" tf:"measurement_duration,omitempty"`

	// +kubebuilder:validation:Optional
	MinZoneSize *int64 `json:"minZoneSize,omitempty" tf:"min_zone_size,omitempty"`

	// +kubebuilder:validation:Optional
	StabilizationDuration *int64 `json:"stabilizationDuration,omitempty" tf:"stabilization_duration,omitempty"`

	// +kubebuilder:validation:Optional
	WarmupDuration *int64 `json:"warmupDuration,omitempty" tf:"warmup_duration,omitempty"`
}

// InstanceGroupSpec defines the desired state of InstanceGroup
type InstanceGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceGroupParameters `json:"forProvider"`
}

// InstanceGroupStatus defines the observed state of InstanceGroup.
type InstanceGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceGroup is the Schema for the InstanceGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type InstanceGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              InstanceGroupSpec   `json:"spec"`
	Status            InstanceGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceGroupList contains a list of InstanceGroups
type InstanceGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []InstanceGroup `json:"items"`
}

// Repository type metadata.
var (
	InstanceGroup_Kind             = "InstanceGroup"
	InstanceGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: InstanceGroup_Kind}.String()
	InstanceGroup_KindAPIVersion   = InstanceGroup_Kind + "." + CRDGroupVersion.String()
	InstanceGroup_GroupVersionKind = CRDGroupVersion.WithKind(InstanceGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&InstanceGroup{}, &InstanceGroupList{})
}
