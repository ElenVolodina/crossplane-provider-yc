/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttachedTargetGroupObservation struct {
}

type AttachedTargetGroupParameters struct {

	// +kubebuilder:validation:Required
	Healthcheck []HealthcheckParameters `json:"healthcheck" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	TargetGroupID *string `json:"targetGroupId" tf:"target_group_id,omitempty"`
}

type ExternalAddressSpecObservation struct {
}

type ExternalAddressSpecParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	IPVersion *string `json:"ipVersion,omitempty" tf:"ip_version,omitempty"`
}

type HTTPOptionsObservation struct {
}

type HTTPOptionsParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`
}

type HealthcheckObservation struct {
}

type HealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	HTTPOptions []HTTPOptionsParameters `json:"httpOptions,omitempty" tf:"http_options,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	Interval *int64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	TCPOptions []TCPOptionsParameters `json:"tcpOptions,omitempty" tf:"tcp_options,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type InternalAddressSpecObservation struct {
}

type InternalAddressSpecParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	IPVersion *string `json:"ipVersion,omitempty" tf:"ip_version,omitempty"`

	// +kubebuilder:validation:Required
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type ListenerObservation struct {
}

type ListenerParameters struct {

	// +kubebuilder:validation:Optional
	ExternalAddressSpec []ExternalAddressSpecParameters `json:"externalAddressSpec,omitempty" tf:"external_address_spec,omitempty"`

	// +kubebuilder:validation:Optional
	InternalAddressSpec []InternalAddressSpecParameters `json:"internalAddressSpec,omitempty" tf:"internal_address_spec,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	TargetPort *int64 `json:"targetPort,omitempty" tf:"target_port,omitempty"`
}

type NetworkLoadBalancerObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`
}

type NetworkLoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	AttachedTargetGroup []AttachedTargetGroupParameters `json:"attachedTargetGroup,omitempty" tf:"attached_target_group,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Listener []ListenerParameters `json:"listener,omitempty" tf:"listener,omitempty"`

	// +kubebuilder:validation:Optional
	RegionID *string `json:"regionId,omitempty" tf:"region_id,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TCPOptionsObservation struct {
}

type TCPOptionsParameters struct {

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`
}

// NetworkLoadBalancerSpec defines the desired state of NetworkLoadBalancer
type NetworkLoadBalancerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NetworkLoadBalancerParameters `json:"forProvider"`
}

// NetworkLoadBalancerStatus defines the observed state of NetworkLoadBalancer.
type NetworkLoadBalancerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NetworkLoadBalancerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkLoadBalancer is the Schema for the NetworkLoadBalancers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type NetworkLoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkLoadBalancerSpec   `json:"spec"`
	Status            NetworkLoadBalancerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkLoadBalancerList contains a list of NetworkLoadBalancers
type NetworkLoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkLoadBalancer `json:"items"`
}

// Repository type metadata.
var (
	NetworkLoadBalancer_Kind             = "NetworkLoadBalancer"
	NetworkLoadBalancer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NetworkLoadBalancer_Kind}.String()
	NetworkLoadBalancer_KindAPIVersion   = NetworkLoadBalancer_Kind + "." + CRDGroupVersion.String()
	NetworkLoadBalancer_GroupVersionKind = CRDGroupVersion.WithKind(NetworkLoadBalancer_Kind)
)

func init() {
	SchemeBuilder.Register(&NetworkLoadBalancer{}, &NetworkLoadBalancerList{})
}
