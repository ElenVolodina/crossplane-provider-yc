/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendGroupObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`
}

type BackendGroupParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// +kubebuilder:validation:Optional
	GrpcBackend []GrpcBackendParameters `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPBackend []HTTPBackendParameters `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`
}

type GrpcBackendObservation struct {
}

type GrpcBackendParameters struct {

	// +kubebuilder:validation:Optional
	Healthcheck []HealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancingConfig []LoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +kubebuilder:validation:Required
	TargetGroupIds []*string `json:"targetGroupIds" tf:"target_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Weight *int64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GrpcHealthcheckObservation struct {
}

type GrpcHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPBackendHealthcheckObservation struct {
}

type HTTPBackendHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	GrpcHealthcheck []HealthcheckGrpcHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HealthcheckPort *int64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// +kubebuilder:validation:Optional
	StreamHealthcheck []HealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendLoadBalancingConfigObservation struct {
}

type HTTPBackendLoadBalancingConfigParameters struct {

	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *int64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// +kubebuilder:validation:Optional
	PanicThreshold *int64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendObservation struct {
}

type HTTPBackendParameters struct {

	// +kubebuilder:validation:Optional
	Healthcheck []HTTPBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []HTTPBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +kubebuilder:validation:Required
	TargetGroupIds []*string `json:"targetGroupIds" tf:"target_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Weight *int64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendTLSObservation struct {
}

type HTTPBackendTLSParameters struct {

	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []TLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPHealthcheckObservation struct {
}

type HTTPHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HealthcheckGrpcHealthcheckObservation struct {
}

type HealthcheckGrpcHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckHTTPHealthcheckObservation struct {
}

type HealthcheckHTTPHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HealthcheckObservation struct {
}

type HealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	GrpcHealthcheck []GrpcHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HealthcheckPort *int64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckStreamHealthcheckObservation struct {
}

type HealthcheckStreamHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type LoadBalancingConfigObservation struct {
}

type LoadBalancingConfigParameters struct {

	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *int64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// +kubebuilder:validation:Optional
	PanicThreshold *int64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamHealthcheckObservation struct {
}

type StreamHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type TLSObservation struct {
}

type TLSParameters struct {

	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []ValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSValidationContextObservation struct {
}

type TLSValidationContextParameters struct {

	// +kubebuilder:validation:Optional
	TrustedCaBytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCaID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextObservation struct {
}

type ValidationContextParameters struct {

	// +kubebuilder:validation:Optional
	TrustedCaBytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCaID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

// BackendGroupSpec defines the desired state of BackendGroup
type BackendGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BackendGroupParameters `json:"forProvider"`
}

// BackendGroupStatus defines the observed state of BackendGroup.
type BackendGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BackendGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroup is the Schema for the BackendGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloudjet}
type BackendGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackendGroupSpec   `json:"spec"`
	Status            BackendGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroupList contains a list of BackendGroups
type BackendGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackendGroup `json:"items"`
}

// Repository type metadata.
var (
	BackendGroup_Kind             = "BackendGroup"
	BackendGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BackendGroup_Kind}.String()
	BackendGroup_KindAPIVersion   = BackendGroup_Kind + "." + CRDGroupVersion.String()
	BackendGroup_GroupVersionKind = CRDGroupVersion.WithKind(BackendGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&BackendGroup{}, &BackendGroupList{})
}
